From c649509d4b4a91a603c8185ab72f99427579f50c Mon Sep 17 00:00:00 2001
From: Paul Mundt <lethal@linux-sh.org>
Date: Thu, 24 Nov 2011 20:20:53 +0900
Subject: serial: sh-sci: Add support for loopback mode.

This plugs in loopback control for SCFCR-enabled ports and plugs it in
via the TIOCM_LOOP control, as others do.

Signed-off-by: Paul Mundt <lethal@linux-sh.org>
(cherry picked from commit dc7e3ef7dade7041fb1809f2a5403efac655a791)

Signed-off-by: Simon Horman <horms@verge.net.au>
---
 drivers/tty/serial/sh-sci.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index a60ccdb..b519332 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -1113,10 +1113,23 @@ static unsigned int sci_tx_empty(struct uart_port *port)
  * handled via the ->init_pins() op, which is a bit of a one-way street,
  * lacking any ability to defer pin control -- this will later be
  * converted over to the GPIO framework).
+ *
+ * Other modes (such as loopback) are supported generically on certain
+ * port types, but not others. For these it's sufficient to test for the
+ * existence of the support register and simply ignore the port type.
  */
 static void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
-	/* Nothing to do here. */
+	if (mctrl & TIOCM_LOOP) {
+		struct plat_sci_reg *reg;
+
+		/*
+		 * Standard loopback mode for SCFCR ports.
+		 */
+		reg = sci_getreg(port, SCFCR);
+		if (reg->size)
+			sci_out(port, SCFCR, sci_in(port, SCFCR) | 1);
+	}
 }
 
 static unsigned int sci_get_mctrl(struct uart_port *port)
-- 
1.7.10

