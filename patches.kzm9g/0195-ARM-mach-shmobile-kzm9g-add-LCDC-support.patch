From 769707e6bbe540cf277c165031d34f12fdd38f13 Mon Sep 17 00:00:00 2001
From: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date: Tue, 10 Apr 2012 20:58:33 -0700
Subject: ARM: mach-shmobile: kzm9g: add LCDC support

AS3711 chip initalization is required for enabling LCDC backlight,
but there is no driver for this chip.
So, this patch sends its settings when boot.

Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Tested-by: Simon Horman <horms@verge.net.au>
Acked-by: Magnus Damm <damm@opensource.se>
Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

Conflicts:

	arch/arm/mach-shmobile/board-kzm9g.c

N.B: Not present in mainline yet

Signed-off-by; Simon Horman <horms@verge.net.au>
---
 arch/arm/mach-shmobile/board-kzm9g.c | 144 +++++++++++++++++++++++++++++++++++
 1 file changed, 144 insertions(+)

diff --git a/arch/arm/mach-shmobile/board-kzm9g.c b/arch/arm/mach-shmobile/board-kzm9g.c
index a7f05f6..3e3da46 100644
--- a/arch/arm/mach-shmobile/board-kzm9g.c
+++ b/arch/arm/mach-shmobile/board-kzm9g.c
@@ -16,20 +16,133 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
+
+#include <linux/delay.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <mach/irqs.h>
 #include <mach/sh73a0.h>
 #include <mach/common.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/hardware/gic.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
+#include <video/sh_mobile_lcdc.h>
+
+/* LCDC */
+static struct fb_videomode kzm_lcdc_mode = {
+	.name		= "WVGA Panel",
+	.xres		= 800,
+	.yres		= 480,
+	.left_margin	= 220,
+	.right_margin	= 110,
+	.hsync_len	= 70,
+	.upper_margin	= 20,
+	.lower_margin	= 5,
+	.vsync_len	= 5,
+	.sync		= 0,
+};
+
+static struct sh_mobile_lcdc_info lcdc_info = {
+	.clock_source = LCDC_CLK_BUS,
+	.ch[0] = {
+		.chan		= LCDC_CHAN_MAINLCD,
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.interface_type	= RGB24,
+		.lcd_modes	= &kzm_lcdc_mode,
+		.num_modes	= 1,
+		.clock_divider	= 5,
+		.flags		= 0,
+		.panel_cfg = {
+			.width	= 152,
+			.height	= 91,
+		},
+	}
+};
+
+static struct resource lcdc_resources[] = {
+	[0] = {
+		.name	= "LCDC",
+		.start	= 0xfe940000,
+		.end	= 0xfe943fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= intcs_evt2irq(0x580),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lcdc_device = {
+	.name		= "sh_mobile_lcdc_fb",
+	.num_resources	= ARRAY_SIZE(lcdc_resources),
+	.resource	= lcdc_resources,
+	.dev	= {
+		.platform_data	= &lcdc_info,
+		.coherent_dma_mask = ~0,
+	},
+};
 
 static struct platform_device *kzm_devices[] __initdata = {
+	&lcdc_device,
 };
 
+/*
+ * FIXME
+ *
+ * This is quick hack for enabling LCDC backlight
+ */
+static int __init as3711_enable_lcdc_backlight(void)
+{
+	struct i2c_adapter *a = i2c_get_adapter(0);
+	struct i2c_msg msg;
+	int i, ret;
+	__u8 magic[] = {
+		0x40, 0x2a,
+		0x43, 0x3c,
+		0x44, 0x3c,
+		0x45, 0x3c,
+		0x54, 0x03,
+		0x51, 0x00,
+		0x51, 0x01,
+		0xff, 0x00, /* wait */
+		0x43, 0xf0,
+		0x44, 0xf0,
+		0x45, 0xf0,
+	};
+
+	if (!machine_is_kzm9g())
+		return 0;
+
+	if (!a)
+		return 0;
+
+	msg.addr	= 0x40;
+	msg.len		= 2;
+	msg.flags	= 0;
+
+	for (i = 0; i < ARRAY_SIZE(magic); i += 2) {
+		msg.buf = magic + i;
+
+		if (0xff == msg.buf[0]) {
+			udelay(500);
+			continue;
+		}
+
+		ret = i2c_transfer(a, &msg, 1);
+		if (ret < 0) {
+			pr_err("i2c transfer fail\n");
+			break;
+		}
+	}
+
+	return 0;
+}
+device_initcall(as3711_enable_lcdc_backlight);
+
 static void __init kzm_init(void)
 {
 	sh73a0_pinmux_init();
@@ -40,6 +153,37 @@ static void __init kzm_init(void)
 	gpio_request(GPIO_FN_SCIFA4_RTS_, NULL);
 	gpio_request(GPIO_FN_SCIFA4_CTS_, NULL);
 
+	/* LCDC */
+	gpio_request(GPIO_FN_LCDD23,	NULL);
+	gpio_request(GPIO_FN_LCDD22,	NULL);
+	gpio_request(GPIO_FN_LCDD21,	NULL);
+	gpio_request(GPIO_FN_LCDD20,	NULL);
+	gpio_request(GPIO_FN_LCDD19,	NULL);
+	gpio_request(GPIO_FN_LCDD18,	NULL);
+	gpio_request(GPIO_FN_LCDD17,	NULL);
+	gpio_request(GPIO_FN_LCDD16,	NULL);
+	gpio_request(GPIO_FN_LCDD15,	NULL);
+	gpio_request(GPIO_FN_LCDD14,	NULL);
+	gpio_request(GPIO_FN_LCDD13,	NULL);
+	gpio_request(GPIO_FN_LCDD12,	NULL);
+	gpio_request(GPIO_FN_LCDD11,	NULL);
+	gpio_request(GPIO_FN_LCDD10,	NULL);
+	gpio_request(GPIO_FN_LCDD9,	NULL);
+	gpio_request(GPIO_FN_LCDD8,	NULL);
+	gpio_request(GPIO_FN_LCDD7,	NULL);
+	gpio_request(GPIO_FN_LCDD6,	NULL);
+	gpio_request(GPIO_FN_LCDD5,	NULL);
+	gpio_request(GPIO_FN_LCDD4,	NULL);
+	gpio_request(GPIO_FN_LCDD3,	NULL);
+	gpio_request(GPIO_FN_LCDD2,	NULL);
+	gpio_request(GPIO_FN_LCDD1,	NULL);
+	gpio_request(GPIO_FN_LCDD0,	NULL);
+	gpio_request(GPIO_FN_LCDDISP,	NULL);
+	gpio_request(GPIO_FN_LCDDCK,	NULL);
+
+	gpio_request(GPIO_PORT222,	NULL);
+	gpio_direction_output(GPIO_PORT222, 1);
+
 #ifdef CONFIG_CACHE_L2X0
 	/* Early BRESP enable, Shared attribute override enable, 64K*8way */
 	l2x0_init(__io(0xf0100000), 0x40460000, 0x82000fff);
-- 
1.7.10.2.565.gbd578b5

