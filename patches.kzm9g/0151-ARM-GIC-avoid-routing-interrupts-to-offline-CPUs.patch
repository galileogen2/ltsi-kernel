From aada114ebfda78d2fba02d654fa67b075e31d27d Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Thu, 21 Jul 2011 15:00:57 +0100
Subject: ARM: GIC: avoid routing interrupts to offline CPUs

The irq_set_affinity() method can be called with masks which include
offline CPUs.  This allows offline CPUs to have interrupts routed to
them by writing to /proc/irq/*/smp_affinity after hotplug has taken
a CPU offline.  Fix this by ensuring that we select a target CPU
present in both the required affinity and the online CPU mask.

Ensure that we return IRQ_SET_MASK_OK (which happens to be 0) on
success to ensure generic code copies the new mask into the irq_data
structure.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
(cherry picked from commit 5dfc54e087c15f823ee9b6541d2f0f314e69cbed)

Signed-off-by: Simon Horman <horms@verge.net.au>
---
 arch/arm/common/gic.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 2ba61e5..3227ca9 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -173,10 +173,10 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 {
 	void __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + (gic_irq(d) & ~3);
 	unsigned int shift = (d->irq % 4) * 8;
-	unsigned int cpu = cpumask_first(mask_val);
+	unsigned int cpu = cpumask_any_and(mask_val, cpu_online_mask);
 	u32 val, mask, bit;
 
-	if (cpu >= 8)
+	if (cpu >= 8 || cpu >= nr_cpu_ids)
 		return -EINVAL;
 
 	mask = 0xff << shift;
@@ -187,7 +187,7 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 	writel_relaxed(val | bit, reg);
 	spin_unlock(&irq_controller_lock);
 
-	return 0;
+	return IRQ_SET_MASK_OK;
 }
 #endif
 
-- 
1.7.10.2.565.gbd578b5

