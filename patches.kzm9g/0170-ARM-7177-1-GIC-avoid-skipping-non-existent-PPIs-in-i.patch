From c7dd20bb08c673ce9ce055074c77d92760bc03ac Mon Sep 17 00:00:00 2001
From: Will Deacon <will.deacon@arm.com>
Date: Fri, 25 Nov 2011 19:23:36 +0100
Subject: ARM: 7177/1: GIC: avoid skipping non-existent PPIs in irq_start
 calculation

Commit 4294f8baa ("ARM: gic: add irq_domain support") defines irq_start
as irq_start = (irq_start & ~31) + 16; On a platform with a GIC and a
CPU without PPIs, this results in irq_start being off by 16.

This patch fixes gic_init so that we only carve out a PPI space when
PPIs exist for the GIC being initialised.

Cc: Rob Herring <rob.herring@calxeda.com>
Signed-off-by: Will Deacon <will.deacon@arm.com>
Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
(cherry picked from commit fe41db7b3aca512e19b8ef4fbd5ad55545005d25)

Signed-off-by: Simon Horman <horms@verge.net.au>
---
 arch/arm/common/gic.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 432c879..0b95dc5 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -607,13 +607,16 @@ void __init gic_init(unsigned int gic_nr, int irq_start,
 	 * For primary GICs, skip over SGIs.
 	 * For secondary GICs, skip over PPIs, too.
 	 */
+	domain->hwirq_base = 32;
 	if (gic_nr == 0) {
 		gic_cpu_base_addr = cpu_base;
-		domain->hwirq_base = 16;
-		if (irq_start > 0)
-			irq_start = (irq_start & ~31) + 16;
-	} else
-		domain->hwirq_base = 32;
+
+		if ((irq_start & 31) > 0) {
+			domain->hwirq_base = 16;
+			if (irq_start != -1)
+				irq_start = (irq_start & ~31) + 16;
+		}
+	}
 
 	/*
 	 * Find out how many interrupts are supported.
-- 
1.7.10.2.565.gbd578b5

