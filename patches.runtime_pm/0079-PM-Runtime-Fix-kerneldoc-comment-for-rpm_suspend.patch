From 5fd4a40128aef39588491371e45508501db6c3d6 Mon Sep 17 00:00:00 2001
From: Ming Lei <ming.lei@canonical.com>
Date: Wed, 12 Oct 2011 11:53:32 +0800
Subject: PM / Runtime: Fix kerneldoc comment for rpm_suspend()

This patch fix kerneldoc comments for rpm_suspend():

 - 'Cancel a pending idle notification' should be put before, also
   should be changed to 'Cancel a pending idle notification,
   autosuspend or suspend'.

 - idle notification for the device after succeeding suspend has
   been removed, so update the comment accordingly.

[rjw: Modified the subject and changelog slightly.]

Signed-off-by: Ming Lei <ming.lei@canonical.com>
Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
(cherry picked from commit 47d8f0bac0fda4c15a030f92cd6da6c6bed87459)

Signed-off-by: Simon Horman <horms@verge.net.au>
---
 drivers/base/power/runtime.c |   18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 7a6fb5e..aa23a64 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -286,14 +286,16 @@ static int rpm_callback(int (*cb)(struct device *), struct device *dev)
  * @dev: Device to suspend.
  * @rpmflags: Flag bits.
  *
- * Check if the device's runtime PM status allows it to be suspended.  If
- * another suspend has been started earlier, either return immediately or wait
- * for it to finish, depending on the RPM_NOWAIT and RPM_ASYNC flags.  Cancel a
- * pending idle notification.  If the RPM_ASYNC flag is set then queue a
- * suspend request; otherwise run the ->runtime_suspend() callback directly.
- * If a deferred resume was requested while the callback was running then carry
- * it out; otherwise send an idle notification for the device (if the suspend
- * failed) or for its parent (if the suspend succeeded).
+ * Check if the device's runtime PM status allows it to be suspended.
+ * Cancel a pending idle notification, autosuspend or suspend. If
+ * another suspend has been started earlier, either return immediately
+ * or wait for it to finish, depending on the RPM_NOWAIT and RPM_ASYNC
+ * flags. If the RPM_ASYNC flag is set then queue a suspend request;
+ * otherwise run the ->runtime_suspend() callback directly. If a deferred
+ * resume was requested while the callback was running then carry it out;
+ * otherwise send an idle notification for its parent (if the suspend
+ * succeeded and both ignore_children of parent->power and irq_safe of
+ * dev->power are not set).
  *
  * This function must be called under dev->power.lock with interrupts disabled.
  */
-- 
1.7.10.1.362.g242cab3

